---
layout: post
title: "ê°œì¸ë³„ ë¬¸ë²• ì˜¤ë¥˜ ì§„ë‹¨ ê¸°ëŠ¥ êµ¬ìƒ(2025-04-29 ~ 2025-04-30)[ì¥ê²½ì€]"
date: 2025-04-29 10:00:00 +0900
typora-root-url: ../
---

### ê¸°ëŠ¥ ì •ì˜

> í•™ìƒì´ í‹€ë¦° ì½”ë“œë¥¼ 15íšŒ ì œì¶œí–ˆì„ ë•Œ 3íšŒ ì´ìƒ ë²”í•˜ëŠ” ì‹¤ìˆ˜ë¥¼ ë¶„ì„í•˜ì—¬ ê´€ë ¨ ê°œë…ê³¼ ë¬¸ì œë¥¼ ì¶”ì²œí•˜ëŠ” ê¸°ëŠ¥
>

### í‹€ë¦° ì‹¤ìˆ˜ ìœ í˜• ì •ì˜

- ë‹¨ìˆœ ì˜¤íƒ€(ì„¸ë¯¸ì½œë¡  ë“±)
- í•¨ìˆ˜ í˜¸ì¶œ ì˜¤ë¥˜
- ìë£Œí˜• ì„ ì–¸ ì˜¤ë¥˜

### êµ¬í˜„ ë°©ì‹

- í•™ìƒ ì œì¶œ ê¸°ë¡ tableì— í‹€ë¦° ì½”ë“œ ê¸°ë¡ì— ëŒ€í•œ ìˆ˜ì§‘
    - solution tableì˜ result í™•ì¸
- í‹€ë¦° ì½”ë“œì˜ ë¬¸ì œ ë¶„ë¥˜ í™•ì¸
    - problem tableì˜ í•´ë‹¹ ë¬¸ì œ íƒœê·¸ ì •ë³´ í™•ì¸
- í•™ìƒ ì·¨ì•½ì  table ìƒì„±
    - í•™ìƒ id
    - ë¬¸ì œ id
    - ì‹¤ìˆ˜ ìœ í˜•

---

## ì‹¤ì œ êµ¬í˜„

### 1) cmake ì„¤ì¹˜

`sudo apt update`

`sudo apt install cmake`

- ê¹”ê³  í™•ì¸í–ˆì„ ë•Œ 3.20.0 ì´ìƒì´ì–´ì•¼í•¨.

`cmake â€”version`

### 2) python ì„¤ì¹˜

- ê¹”ê³  í™•ì¸í–ˆì„ ë•Œ 3.8 ì´ìƒì´ì–´ì•¼í•¨.

`python â€”version`

### 3) zlib ì„¤ì¹˜

`sudo apt install zlib1g-dev`

- ê¹”ê³  í™•ì¸í–ˆì„ ë•Œ, ì•„ë˜ì˜ ë¬¸êµ¬ê°€ í™•ì¸ë˜ì–´ì•¼í•¨.

`dpkg -l | grep zlib`

> ii  zlib1g:amd64                         1:1.2.11.dfsg-2ubuntu9.2                amd64        compression library - runtime
> ii  zlib1g-dev:amd64                     1:1.2.11.dfsg-2ubuntu9.2                amd64        compression library - development
>

- ê·¸ë¦¬ê³  ë²„ì „ì´ 1.2.3.4ì¸ì§€ í™•ì¸
    - ë‚˜ëŠ” 1.2.11 ì´ë¯€ë¡œ ì¶©ì¡±í•˜ëŠ” ê²ƒì„ í™•ì¸í•¨

### 4) GNU make ì„¤ì¹˜

`sudo apt install make`

- ê¹”ê³  í™•ì¸í–ˆì„ ë•Œ, 3.79 ë˜ëŠ” 3.79.1 ì´ì–´ì•¼í•¨.
- í•˜ì§€ë§Œ ë‚˜ëŠ” 4.3ìœ¼ë¡œ ì„¤ì¹˜ë¨ (ì£¼ì˜)

`make --version`

### 5) PyYAML ì„¤ì¹˜

`pip3 install pyyaml`

- ê¹”ê³  í™•ì¸í–ˆì„ ë•Œ, 5.1 ì´ìƒì´ì–´ì•¼í•¨.

`pip show pyyaml`

### 6) LLVM ë¹Œë“œ

â€¢ `git clone https://github.com/llvm/llvm-project.git`

---

â†’ ì€ ë‹¤ ë¶€ì§ˆ ì—†ì—ˆë‹¤. í•˜ë£¨ì¢…ì¼ ê¹”ì•˜ëŠ”ë° llvm git cloneì´ ë˜ì§€ ì•Šì•˜ë‹¤.

ìš°ë¶„íˆ¬ ìƒì—ì„œ ì•„ë˜ë¶€í„° ì‘ì„±í•˜ë©´ ëœë‹¤.

### 1) LLVM ì„¤ì¹˜

`sudo apt install llvm`

### 2) clang ì„¤ì¹˜

`pip install clang`

---

## ì»´íŒŒì¼ ì˜µì…˜

### 1) í…ŒìŠ¤íŠ¸ ì½”ë“œ

```python
#include <stdio.h>
int foo(int x){
	
}

int main(void){
	int a;
	printf("Hello World");
	return 0;
}
```

- ì´ìš©ë˜ì§€ ì•Šì€ í•¨ìˆ˜
- ì´ìš©ë˜ì§€ ì•Šì€ í•¨ìˆ˜ì˜ ì¸ì
- ì´ˆê¸°í™”ë˜ì§€ ì•Šì€ ë³€ìˆ˜ a

### 2) ì»´íŒŒì¼ ì˜µì…˜

- `-Wall`
    - ì¼ë°˜ì ì¸ ê²½ê³  ëŒ€ë¶€ë¶„ í™œì„±í™”
    
    > í•¨ìˆ˜ì— ë¦¬í„´ì´ ì—†ìŒ
    > aê°€ ì´ˆê¸°í™”ë˜ì§€ ì•ŠìŒ
    >
- `-Wextra`
    - ì¶”ê°€ì ì¸ ê²½ê³ 
    
    > í•¨ìˆ˜ ì¸ì xê°€ ì´ìš©ë˜ì§€ ì•ŠìŒ
    > í•¨ìˆ˜ì— ë¦¬í„´ì´ ì—†ìŒ
    >
- -`Wuninitialized`
    - ì´ˆê¸°í™”ë˜ì§€ ì•Šì€ ë³€ìˆ˜ ê²½ê³ 
    
    > í•¨ìˆ˜ì— ë¦¬í„´ì´ ì—†ìŒ
    >
    - í•´ë‹¹ ì˜µì…˜ì€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì€ ë³€ìˆ˜ë¥¼ ì´ìš©í–ˆì„ ë•Œ ê²½ê³ ë¥¼ í‘œì‹œí•¨
    - ì•„ë˜ ì½”ë“œì˜ ê²½ìš° ìœ„ì˜ ì˜¤ë¥˜ë¥¼ ì¶œë ¥í•¨.
    
    ```python
    #include <stdio.h>
    int main(){
    	int x;
    	printf("%d", x);
    	return 0;
    }
    ```
    
- `-O1`
    - clangì˜ íë¦„ ë¶„ì„ ëª¨ë“œ
    
    > í•¨ìˆ˜ì— ë¦¬í„´ì´ ì—†ìŒ
    >

â‡’ ì‹¤ì œë¡œ ì´ˆê¸°í™”ë˜ì§€ ì•Šì€ ë³€ìˆ˜ë¥¼ í™•ì¸í•  ìˆ˜ ì—†ì—ˆìŒ

- `-Weverything`
    - ëª¨ë“  ê²½ê³ ë¥¼ í™œì„±í™”
    
    > í•¨ìˆ˜ ì¸ì xê°€ ì´ìš©ë˜ì§€ ì•ŠìŒ
    > í•¨ìˆ˜ fooì˜ í”„ë¡œí† íƒ€ì… ì„ ì–¸ì´ ì—†ìŒ
    > í•¨ìˆ˜ ì•ì— static ì¶”ê°€í•  ê²ƒì„ ê¶Œê³ 
    > í•¨ìˆ˜ì— ë¦¬í„´ì´ ì—†ìŒ
    > ë³€ìˆ˜ aê°€ ì´ìš©ë˜ì§€ ì•ŠìŒ
    >

â‡’ ê³¼ë„í•œ ì˜µì…˜

- `-Wreturn-type`
    - í•´ë‹¹ ì˜µì…˜ì€ í•„ìš”í•´ë³´ì„

### 3) ì˜¤ë¥˜ ì¢…ë¥˜

- Ignored
- Note
- Remark
- Warning
- Error
- Fatal

### 4) ì»´íŒŒì¼ í›„ ì˜¤ë¥˜ ë©”ì„¸ì§€ íŒŒì‹±

```python
import re

def extract_error_context(error_message, source_code_path):
    pattern = r"^(.*?):(\d+):(\d+): (warning|error): (.*?) \[(.*?)\]$"
    match = re.match(pattern, error_message)

    if not match:
        raise ValueError("Invalid Clang error message format")

    file_name, line_str, col_str, level, message, flag = match.groups()
    line = int(line_str)
    column = int(col_str)

    try:
        with open(source_code_path, 'r') as f:
            lines = f.readlines()
    except FileNotFoundError:
        raise FileNotFoundError(f"File '{source_code_path}' not found")

    total_lines = len(lines)
    start = max(0, line - 2)         # ì—ëŸ¬ ì¤„ì˜ ì´ì „ ì¤„
    end = min(total_lines, line + 1) # ì—ëŸ¬ ì¤„ì˜ ë‹¤ìŒ ì¤„ í¬í•¨

    print(f"\nğŸ“‚ File: {file_name}")
    print(f"ğŸ” Error: {level.upper()} on line {line}, column {column}")
    print(f"âš ï¸ Message: {message} [{flag}]\n")

    for i in range(start, end):
        prefix = ">>" if (i + 1) == line else "  "
        line_number = f"{i + 1:>4}"
        code_line = lines[i].rstrip("\n")
        print(f"{prefix} {line_number}: {code_line}")
        if (i + 1) == line:
            caret_pos = " " * (column - 1)
            print(f"     {' ' * (len(line_number) + 2)}{caret_pos}^")

# ì˜ˆì‹œ
error_msg = "hello.c:4:1: warning: control reaches end of non-void function [-Wreturn-type]"
extract_error_context(error_msg, "hello.c")

```

![image (2)](/images/2025-04-29-ê°œì¸ë³„ ë¬¸ë²• ì˜¤ë¥˜ ì§„ë‹¨ ê¸°ëŠ¥ êµ¬ìƒ(2025-04-29 ~ 2025-04-30)[ì¥ê²½ì€]/image (2).webp)

### 5) ì˜¤ë¥˜ ë©”ì„¸ì§€ ì¢…ë¥˜ì— ë”°ë¼ í•œêµ­ì–´ ì¶œë ¥

```python
import subprocess

def compile_with_clang(source_file, output_file="a.out"):
    cmd = ["clang", source_file, "-o", output_file]
    
    try:
        result = subprocess.run(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True
        )
        
        if result.returncode == 0:
            print("âœ… ì»´íŒŒì¼ ì„±ê³µ!")
        else:
            print("âŒ ì»´íŒŒì¼ ì‹¤íŒ¨!")

        print("\n[STDOUT]:")
        print(result.stdout)

        print("\n[STDERR]:")
        print(result.stderr)

        return result.returncode, result.stdout, result.stderr
    
    except FileNotFoundError:
        print("âŒ Clangì´ ì‹œìŠ¤í…œì— ì„¤ì¹˜ë˜ì–´ ìˆì§€ ì•ŠìŠµë‹ˆë‹¤.")
        return -1, "", "Clang not found"

# ì˜ˆì‹œ ì‹¤í–‰
compile_with_clang("hello.c")

```

- ìµœì¢… íŒŒì‹± íŒ¨í„´
    - `pattern = r"^([^:\s]+):(\d+):(\d+): (warning|error): (.+?)(?: (**\[**[-\w]+**\]**))?$"`

---

## ìµœì¢… ì½”ë“œ

### 1) clang ì»´íŒŒì¼ í›„ íŒŒì‹± ì½”ë“œ

```c
import re
import subprocess

def extract_error_context(error_message, source_code_path):
    pattern = r"^([^:\s]+):(\d+):(\d+): (warning|error): (.+?)(?: (\[[-\w]+\]))?$"
    match = re.match(pattern, error_message)

    if not match:
        return None
        # raise ValueError("Invalid Clang error message format")

    file_name, line_str, col_str, level, message, flag = match.groups()
    line = int(line_str)
    column = int(col_str)

    try:
        with open(source_code_path, 'r') as f:
            lines = f.readlines()
    except FileNotFoundError:
        raise FileNotFoundError(f"File '{source_code_path}' not found")

    total_lines = len(lines)
    start = max(0, line - 2)         # ì—ëŸ¬ ì¤„ì˜ ì´ì „ ì¤„
    end = min(total_lines, line + 1) # ì—ëŸ¬ ì¤„ì˜ ë‹¤ìŒ ì¤„ í¬í•¨

    output_lines = []

    for i in range(start, end):
        prefix = ">>" if (i + 1) == line else "  "
        line_number = f"{i + 1:>4}"
        code_line = lines[i].rstrip("\n")
        output_lines.append(f"{prefix} {line_number}: {code_line}")
        if (i + 1) == line:
            caret_pos = " " * (column - 1)
            output_lines.append(f"     {' ' * (len(line_number) + 2)}{caret_pos}^")

    # ì¤„ë“¤ì„ í•˜ë‚˜ì˜ ë¬¸ìì—´ë¡œ ë³‘í•©
    highlighted_code = "\n".join(output_lines)

    result = {
        "file_name": file_name,
        "level": level.upper(),
        "line": line,
        "column": column,
        "message": message,
        "flag": flag,
        "highlighted_code": highlighted_code
    }

    return result

def compile_with_clang(source_file, output_file="a.out"):
    cmd = ["clang", source_file, "-fsyntax-only"]

    try:
        result = subprocess.run(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True
        )

        if result.returncode == 0:
            print("âœ… ì»´íŒŒì¼ ì„±ê³µ!")
        else:
            print("âŒ ì»´íŒŒì¼ ì‹¤íŒ¨!")

        print("\n[STDOUT]:")
        print(result.stdout)

        print("\n[STDERR]:")
        print(result.stderr)

        return result.    returncode, result.stdout, result.stderr

    except FileNotFoundError:
        print("âŒ Clangì´ ì‹œìŠ¤í…œì— ì„¤ì¹˜ë˜ì–´ ìˆì§€ ì•ŠìŠµë‹ˆë‹¤.")
        return -1, "", "Clang not found"

def compile_and_parsing(code):
        code_filepath = "compile_target_code.c"

        with open(code_filepath, "w") as f:
                f.write(code)

        returncode, stdout, stderr = compile_with_clang(code_filepath)

        results = []
        for line in stderr.splitlines():
                result = extract_error_context(line, code_filepath)
                results.append(result)

        results = [r for r in results if r is not None]
        return results
```

### 2) í•˜ì´í¼ë§í¬ ìƒì„± ì½”ë“œ

```c
import subprocess
import re

BASE_URL = "https://github.com/comjke33/Capstone_Design_Troy/blob/main/ref.md"

CONCEPT_LINKS = {
    # ë³€ìˆ˜ ì„ ì–¸ ê´€ë ¨
    r"use of undeclared identifier|unused variable": {
        "ê°œë…": "ë³€ìˆ˜ ì„ ì–¸",
        "ë§í¬": f"{BASE_URL}#ë³€ìˆ˜-ì„ ì–¸"
    },
    # í•¨ìˆ˜ ì„ ì–¸ ëˆ„ë½
    r"implicit declaration of function|call to undeclared function": {
        "ê°œë…": "í•¨ìˆ˜ ì„ ì–¸ ëˆ„ë½",
        "ë§í¬": f"{BASE_URL}#í•¨ìˆ˜-ì„ ì–¸-ëˆ„ë½"
    },
    # í•¨ìˆ˜ ë°˜í™˜
    r"control reaches end of non-void function|non-void function.*should return|void function.*return|return with a value": {
        "ê°œë…": "í•¨ìˆ˜ ë°˜í™˜",
        "ë§í¬": f"{BASE_URL}#í•¨ìˆ˜ë°˜í™˜"
    },
    # ì„¸ë¯¸ì½œë¡  ëˆ„ë½
    r"expected ';'": {
        "ê°œë…": "ì„¸ë¯¸ì½œë¡  ëˆ„ë½",
        "ë§í¬": f"{BASE_URL}#ì„¸ë¯¸ì½œë¡ -ëˆ„ë½"
    },
    # ê´„í˜¸ ì˜¤ë¥˜
    r"expected '\)'|expected '\]'|expected '\}'": {
        "ê°œë…": "ê´„í˜¸ ë‹«í˜ ì˜¤ë¥˜",
        "ë§í¬": f"{BASE_URL}#ê´„í˜¸-ë‹«í˜-ì˜¤ë¥˜"
    },
    # í‘œí˜„ì‹ ëˆ„ë½
    r"expected expression": {
        "ê°œë…": "í‘œí˜„ì‹ ëˆ„ë½",
        "ë§í¬": f"{BASE_URL}#í‘œí˜„ì‹-ëˆ„ë½"
    },
    # í¬ì¸í„° ì˜¤ë¥˜
    r"incompatible pointer type|incompatible integer to pointer conversion": {
        "ê°œë…": "í¬ì¸í„°",
        "ë§í¬": f"{BASE_URL}#í¬ì¸í„°"
    },
    # ë°°ì—´ ì¸ë±ì‹± ê´€ë ¨
    r"array index .* is past the end": {
        "ê°œë…": "ë°°ì—´ ì¸ë±ìŠ¤ ì´ˆê³¼",
        "ë§í¬": f"{BASE_URL}#ë°°ì—´-ì¸ë±ìŠ¤-ì´ˆê³¼"
    },
    r"subscripted value is not an array": {
        "ê°œë…": "ë°°ì—´ ì¸ë±ì‹± ì˜¤ë¥˜",
        "ë§í¬": f"{BASE_URL}#ë°°ì—´-ì¸ë±ì‹±-ì˜¤ë¥˜"
    },
    # ì…ì¶œë ¥ í˜•ì‹
    r"format specifies type .* but the argument has type": {
        "ê°œë…": "ì…ì¶œë ¥ í˜•ì‹ ì§€ì •ì",
        "ë§í¬": f"{BASE_URL}#ì…ì¶œë ¥-í˜•ì‹-ì§€ì •ì"
    },
    # ì—°ì‚°ì ì˜¤ë¥˜
    r"invalid operands to binary expression|comparison between": {
        "ê°œë…": "ì—°ì‚°ì ì‚¬ìš© ì˜¤ë¥˜",
        "ë§í¬": f"{BASE_URL}#ì—°ì‚°ì-ì‚¬ìš©-ì˜¤ë¥˜"
    },
    # ë¹„êµ ì—°ì‚°ì
    r"invalid operands to binary expression .* == .*|assignment makes integer": {
        "ê°œë…": "ë¹„êµ ì—°ì‚°ì",
        "ë§í¬": f"{BASE_URL}#ë¹„êµ-ì—°ì‚°ì"
    },
    # ì •ìˆ˜/ì‹¤ìˆ˜ ë¦¬í„°ëŸ´ ì˜¤ë¥˜
    r"invalid suffix": {
        "ê°œë…": "ì •ìˆ˜/ì‹¤ìˆ˜ ë¦¬í„°ëŸ´ ì˜¤ë¥˜",
        "ë§í¬": f"{BASE_URL}#ì •ìˆ˜ì‹¤ìˆ˜-ë¦¬í„°ëŸ´-ì˜¤ë¥˜"
    },
    # í•¨ìˆ˜ ì¤‘ë³µ
    r"redefinition of": {
        "ê°œë…": "í•¨ìˆ˜ ì •ì˜ ì¤‘ë³µ",
        "ë§í¬": f"{BASE_URL}#í•¨ìˆ˜-ì •ì˜-ì¤‘ë³µ"
    },
    # í•¨ìˆ˜ ì¸ì ì˜¤ë¥˜
    r"incompatible type for argument|too few arguments": {
        "ê°œë…": "í•¨ìˆ˜ ì¸ì ìˆœì„œ ì˜¤ë¥˜",
        "ë§í¬": f"{BASE_URL}#í•¨ìˆ˜-ì¸ì-ìˆœì„œ-ì˜¤ë¥˜"
    }
}

def map_to_concepts(errors: str):
    enriched = []
    current_block = []

    for line in errors.splitlines():
        if re.match(r"^.*(error|warning):.*", line):
            if current_block:
                enriched.append("\n".join(current_block))
                current_block = []
            current_block.append(line)
        elif line.strip():
            current_block.append(line)

    if current_block:
        enriched.append("\n".join(current_block))

    result = []
    for block in enriched:
        matched = False
        for pattern, info in CONCEPT_LINKS.items():
            if re.search(pattern, block):
                result.append(f"â— [{info['ê°œë…']}] ê´€ë ¨ ì˜¤ë¥˜ ê°ì§€\n{block}\nâ¡ ì°¸ê³  ë§í¬: {info['ë§í¬']}")
                matched = True
        if not matched:
            result.append(f"âš ï¸ ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜\n{block}")
    return "\n\n".join(result)

def matching_hyperlink(compile_result):

        links = map_to_concepts(errors)

        return links
```

### 3) ì˜¤ë¥˜ ë¶„ë¥˜ ì½”ë“œ

```c
import re

ERROR_PATTERN_MAP = {
    r"use of undeclared identifier|unused variable": "ë³€ìˆ˜ ì„ ì–¸",
    r"control reaches end of non-void function|non-void function.*should return|void function.*return|return with a value": "í•¨ìˆ˜ ë°˜í™˜",
    r"incompatible pointer type|incompatible integer to pointer conversion": "í¬ì¸í„°",
    r"array index .* is past the end|subscripted value is not an array": "ë°°ì—´ ì¸ë±ìŠ¤ ì˜¤ë¥˜",
    r"format specifies type .* but the argument has type": "ì…ì¶œë ¥ í˜•ì‹ ì§€ì •ì",
    r"invalid operands to binary expression|comparison between": "ì—°ì‚°ì ì‚¬ìš© ì˜¤ë¥˜",
    r"invalid suffix": "ì •ìˆ˜ì‹¤ìˆ˜ ë¦¬í„°ëŸ´ ì˜¤ë¥˜",
    r"expected expression": "í‘œí˜„ì‹ ëˆ„ë½"
}

def classify_error(error_msg):
    for pattern, concept in ERROR_PATTERN_MAP.items():
        if re.search(pattern, error_msg):
            return concept
    return "ê¸°íƒ€"
```