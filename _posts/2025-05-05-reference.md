
# C 문법 오류 개념 레퍼런스


---

## 함수 선언 누락 {#함수-선언-누락}
📌 개념 설명

- 함수를 호출하기 전에 선언하지 않으면 `"implicit declaration of function"` 오류가 발생합니다.
- 함수 선언은 보통 헤더 파일에 `void greet();` 처럼 작성하거나, 본문 위에 함수 원형을 명시해야 합니다.

---

### ✅ 올바른 예시 올바른 예시

```c
void greet();  // 선언

int main() {
    greet();    // 선언된 함수 호출
    return 0;
}

void greet() {
    printf("Hi");
}

```

---

### ❌ 잘못된 예시 잘못된 예시

```c
int main() {
    greet(); // 오류: 선언 없이 호출
    return 0;
}

void greet() {
    printf("Hi");
}

```

---

---

## 표현식 누락 {#표현식-누락}
📌 개념 설명

- 조건문, 반복문 또는 계산에서 필요한 표현식이 누락되면 `"expected expression"` 오류가 발생합니다.
- 이는 세미콜론을 잘못 사용했거나 연산 대상이 빠진 경우입니다.

---

### ❌ 잘못된 예시 잘못된 예시

```c
int main() {
    if () {  // 오류: 조건 표현식 없음
        printf("오류");
    }

    int x = ; // 오류: 대입값 없음
}

```

---

---

## 정수/실수 리터럴 오류 {#정수실수-리터럴-오류}
📌 개념 설명

- 숫자 뒤에 잘못된 접미사(예: `10z`)를 붙이면 `"invalid suffix"` 오류가 발생합니다.
- C에서는 정수형 접미사로 `U`, `L`, `LL` 등만 허용되며, 부동소수점에는 `f`, `F` 등이 사용됩니다.

---

### ❌ 잘못된 예시 잘못된 예시

```c
int x = 10z;   // 오류: z는 유효한 접미사가 아님
float y = 1.2q; // 오류: q는 허용되지 않음

```

---

---

## 배열 인덱싱 오류 {#배열-인덱싱-오류}
📌 개념 설명

- 배열이 아닌 값에 대해 인덱싱 연산 `[]`를 시도하면 `"subscripted value is not an array"` 오류가 발생합니다.

---

### ❌ 잘못된 예시 잘못된 예시

```c
int x = 10;
x[0] = 5; // 오류: x는 배열이 아님

```

---

---

## 연산자 사용 오류 {#연산자-사용-오류}
📌 개념 설명

- 연산자의 좌변 또는 우변 타입이 잘못되었거나, 타입 간 연산이 불가능할 경우 `"invalid operands to binary expression"` 오류가 발생합니다.

---

### ❌ 잘못된 예시 잘못된 예시

```c
int x = 10;
char *str = "hello";
int result = x + str; // 오류: 정수 + 문자열 포인터 연산 불가능

```

---

## 함수 반환 {#함수-반환}
📌 개념 설명

- 모든 함수는 선언된 반환 타입(return type)에 따라 `return` 문을 사용해야 합니다.
- `int`, `float`, `char` 등 반환 타입이 있는 함수는 값을 반환해야 하며, `void` 함수는 값을 반환하면 오류가 발생합니다.
- `return` 문은 모든 분기에서 빠짐없이 작성되어야 하며, 조건문 안에만 존재할 경우 조건을 만족하지 않을 때 반환되지 않는 문제가 발생합니다.

---

### ✅ 올바른 예시 올바른 예시

```c
int getMax() {
	return 100; // int 함수는 반드시 값을 반환
}
void greet() {
	printf("Hello!\\n");
	return; // void 함수는 값 없이 return만 가능
}
int compare(int a) {
	if (a > 0) return 1;
	else return 0; // 모든 분기에서 반환
}

```

---

### ❌ 잘못된 예시 잘못된 예시

```c
void greet() {
    return 1; // 오류: void 함수에서 값을 반환
}
int getMin() {
// 오류: 반환값 없음
}
int check(int x) {
    if (x > 0) return 1;    // else 조건에 return 없음 → 컴파일 경고 또는 오류
}

```

---

---

## 변수 선언 {#변수-선언}
📌 개념 설명

- C 언어에서는 변수를 반드시 사용 전에 선언해야 하며, 타입과 변수 이름을 명확히 지정해야 합니다.
- 선언하지 않은 변수를 사용하면 `"undeclared identifier"` 또는 `"implicit declaration"` 오류가 발생합니다.
- 지역 변수는 선언된 블록(scope) 내에서만 사용할 수 있으며, 유효 범위를 벗어나면 접근할 수 없습니다.
- 또한, 변수를 초기화하지 않고 사용하는 경우 쓰레기 값(임의의 메모리 값) 으로 인해 예측 불가능한 동작이 발생할 수 있습니다.

---

### ✅ 올바른 예시 올바른 예시

```c
int main() {
    int x = 10; // 선언과 초기화
    printf("%d\\n", x);
    int y;
    y = 20; // 선언 후 값 할당
    if (x < y) {
         int diff = y - x; // 블록 내부에서만 유효
            printf("차이: %d\\n", diff);
        }
        return 0;
        }

```

---

### ❌ 잘못된 예시 잘못된 예시

```c
int main() {
    x = 10; // 오류: 선언되지 않은 변수 x
    if (1) {
        int a = 5;
      }
       printf("%d", a); // 오류: 지역 변수 a는 if 블록 바깥에서 접근 불가
       int b;
       printf("%d", b); // 논리 오류: b는 초기화되지 않았음
       return 0;
    }

```

---

---

## 입출력 형식 지정자 {#입출력-형식-지정자}
📌 개념 설명

- `scanf()`와 `printf()`는 C 언어에서 사용하는 대표적인 표준 입출력 함수 입니다.
- 이 함수들은 반드시 형식 지정자(format specifier) 를 사용하여 입력 또는 출력할 변수의 타입을 명시해야 합니다.
- 특히 `scanf()`에서는 입력받은 값을 변수에 저장해야 하므로 **변수의 주소**를 전달해야 하며, 변수 앞에 `&` 주소 연산자가 필요합니다.
- 형식 지정자와 변수 타입이 일치하지 않으면 잘못된 값이 입력되거나, 런타임 오류가 발생할 수 있습니다.

🧠 참고:

| 데이터 타입 | 형식 지정자 |
| --- | --- |
| `int` | `%d` |
| `float` | `%f` |
| `char` | `%c` |
| `char[]` 문자열 | `%s` |

### ✅ 올바른 예시 올바른 예시

```c
int x;
float y;
char c;
char str[100];
scanf("%d", &x);  // 정수 입력
scanf("%f", &y);  // 실수 입력
scanf(" %c", &c); // 문자 입력 (공백 문자 방지 위해 앞에 space)
scanf("%s", str); // 문자열 입력 (& 없이 배열 이름만 전달)
printf("정수: %d\\n", x);
printf("실수: %.2f\\n", y);
printf("문자: %c\\n", c);
printf("문자열: %s\\n", str);

```

---

### ❌ 잘못된 예시 잘못된 예시

```c
int x;
scanf("%d", x); // 오류: 주소 연산자(&) 없음

float y;
scanf("%d", &y); // 오류: 형식 지정자와 타입 불일치

char name[20];
scanf("%s", &name); // 오류: 문자열은 배열 이름만 써야 함 (& 불필요)

```

---

---

## 포인터 {#포인터}
📌 개념 설명

- 포인터는 다른 변수의 주소를 저장하는 변수 입니다. 를 사용하여 선언하며, `&`로 주소를 얻을 수 있습니다.
- 선언한 포인터는 반드시 초기화 후 사용해야 하며, 초기화되지 않은 포인터를 역참조(`p`)하면 Segmentation fault 등 심각한 오류가 발생할 수 있습니다.
- 포인터 타입이 다르면 잘못된 주소 계산이나 정렬 오류 등이 발생할 수 있으므로, 항상 올바른 타입으로 선언해야 합니다.
- 포인터는 배열과 밀접한 관계가 있으며, 동적 메모리 할당 시에도 많이 사용됩니다.

---

### ✅ 올바른 예시 올바른 예시

```c
int x = 10;
int *p = &x; // x의 주소를 p에 저장
printf("x의 값: %d\\n", *p); // 포인터 역참조를 통해 값 접근
*p = 20; // 포인터를 통해 값 수정
printf("x의 새로운 값: %d\\n", x);

```

---

### ❌ 잘못된 예시 잘못된 예시

```c
int *p;
*p = 10; // 오류: 초기화되지 않은 포인터를 역참조 (Segmentation fault)
float f = 3.14;
int *q = &f; // 경고 또는 오류: 타입 불일치 (float → int*)

```

---

💡보충 설명

- 는 포인터 선언 시에는 포인터임을 의미하고, 사용 시에는 역참조를 의미합니다.
- `&`는 변수의 주소를 가져오는 연산자입니다.

📎 예:

```c
int a = 5;
int *ptr = &a;   // 선언: ptr은 int형 변수의 주소를 가짐
printf("%d", *ptr); // 출력: ptr이 가리키는 변수의 값

```

---

---

## 배열 인덱스 초과 {#배열-인덱스-초과}
📌 개념 설명

- 배열은 고정된 크기의 연속된 메모리 공간 입니다.
- 배열의 인덱스는 항상 `0`부터 시작하며, 최대 인덱스는 `배열 크기 - 1`입니다.
- 배열의 범위를 벗어난 인덱스를 접근하면, 정의되지 않은 동작(Undefined Behavior) 이 발생하며 런타임 오류나 예측 불가능한 값 변경이 일어날 수 있습니다.
- 반복문으로 배열을 순회할 때는 반드시 범위를 엄격하게 제한해야 하며, 배열 크기는 `sizeof(arr) / sizeof(arr[0])` 방식으로 구하는 것이 안전합니다.

---

### ✅ 올바른 예시 올바른 예시

```c
int arr[5];
arr[0] = 10;
arr[4] = 50; // 마지막 인덱스 = 크기 - 1
for (int i = 0; i < 5; i++) {
    printf("%d ", arr[i]);
    }// 또는 동적 구하기
int length = sizeof(arr) / sizeof(arr[0]);
for (int i = 0; i < length; i++) {
    printf("%d ", arr[i]);
    }

```

---

### ❌ 잘못된 예시 잘못된 예시

```c
int arr[3];arr[3] = 100; // 오류: 유효 인덱스는 0~2까지
for (int i = 0; i <= 3; i++) { // i==3일 때 오류 발생 가능
    printf("%d ", arr[i]);
    }

```

---

💡보충 설명

- 배열 접근 오류는 컴파일 에러가 아닌 런타임 오류로 드러나는 경우가 많기 때문에, 주의 깊게 테스트해야 합니다.
- 문자열 배열의 경우에도 `str[length] = '\\\\0';` 등을 사용할 때 주의가 필요합니다.

---

---

## 세미콜론 누락 {#세미콜론-누락}
📌 개념 설명

- C 언어는 세미콜론 `;`을 기준으로 문장의 끝을 구분합니다.
- 세미콜론이 빠지면 컴파일러는 문장의 경계를 알 수 없어 `"expected ';'"`, `"syntax error"` 등의 컴파일 오류를 발생시킵니다.
- 특히 여러 문장이 연속될 때 세미콜론을 빼먹으면 다음 줄의 코드가 문법적으로 잘못 해석됩니다.
- 조건문, 반복문, 함수 정의와 달리, 변수 선언과 대입문은 반드시 세미콜론으로 끝나야 합니다.

---

### ✅ 올바른 예시 올바른 예시

```c
int main() {
	int x = 10;
	int y = 20;
	x = x + y;
	printf("%d\\n", x);
	return 0;
}

```

---

### ❌ 잘못된 예시 잘못된 예시

```c
int main() {
    int x = 10  // 오류: 세미콜론 누락
    int y = 20; // 위 문장의 누락으로 함께 오류 발생
    printf("%d\\n", x);
    return 0
    } // 오류: return 뒤에도 세미콜론 누락

```

---

💡 **보충 설명**

- 세미콜론은 조건문이나 반복문 블록 자체에는 필요 없지만, 그 안에 들어가는 실행 문장에는 필요합니다.
- 아래와 같이 조건문을 한 줄로 작성할 경우도 세미콜론은 꼭 필요합니다:

```c
if (x > 0) printf("양수입니다\\n");  // printf 뒤에는 세미콜론!

```

---

---

## 비교 연산자 {#비교-연산자}
📌 개념 설명

- C 언어에서 `==`는 비교 연산자이고, `=`는 대입 연산자입니다.
- 조건문(`if`, `while` 등)에서는 두 값이 같은지를 비교할 때 반드시 `==`를 사용해야 하며, `=`를 쓰면 의도치 않은 대입이 발생합니다.
- 이외에도 `!=` (같지 않다), `<`, `>`, `<=`, `>=` 등의 다양한 비교 연산자가 있으며, 논리 연산자 `&&`, `||` 와 함께 자주 사용됩니다.
- 잘못된 비교 연산자의 사용은 프로그램 흐름을 완전히 왜곡시킬 수 있습니다.

---

### ✅ 올바른 예시 올바른 예시

```c
int x = 5, y = 10;
if (x == y) {
    printf("x와 y는 같습니다\\n");
    }
else {
    printf("x와 y는 다릅니다\\n");
    }
 if (x != 0 && y > 5) {
     printf("조건을 만족합니다\\n");
    }

```

---

### ❌ 잘못된 예시 잘못된 예시

```c
int a = 3, b = 3;
if (a = b) { // 오류: a에 b를 대입하고 항상 true
	printf("항상 실행됩니다\\n");
	}
if (a ! b) {
	// 오류: != 대신 !b (논리 부정) + 문법 오류
	printf("문법 오류 발생\\n");
	}

```

---

💡 보충 설명
- `if (a = b)`는 a에 b를 대입한 후, a가 0이 아니면 true로 평가됩니다.
- 대부분의 컴파일러는 `=`와 `==` 혼동 시 경고를 출력하지만, 논리 오류를 방지하려면 반드시 `==`를 써야 합니다.

---

---

## 무한 루프 및 루프 조건 {#무한-루프-및-루프-조건}
📌 개념 설명

- 반복문(`for`, `while`, `do while`)은 특정 조건을 만족하는 동안 코드를 반복 실행합니다.
- 종료 조건을 명확히 설정하지 않거나, 항상 참인 조건을 넣으면 무한 루프가 발생합니다.
- 의도하지 않은 무한 루프는 프로그램이 멈추지 않는 버그를 야기합니다.
- `break`, `continue` 같은 제어문을 잘못 사용하면 반복 흐름이 왜곡될 수 있습니다.
- 루프의 초기화, 조건, 증감이 제대로 작동하는지도 항상 점검해야 합니다.

---

### ✅ 올바른 예시 올바른 예시

```c
int i = 0;
while (i < 5) {
    printf("i = %d\\n", i);
    i++;  // 종료 조건으로 향함
 }// break 사용 예시
 for (int j = 0; j < 10; j++) {
     if (j == 3) break;  // 반복 중단
     printf("j = %d\\n", j);
    }// continue 사용 예시
 for (int k = 0; k < 5; k++) {
       if (k == 2) continue;  // 2는 건너뜀
       printf("k = %d\\n", k);
    }

```

---

### ❌ 잘못된 예시 잘못된 예시

```c
int i = 0;
while (1) {
    printf("%d ", i);    // 종료 조건 없음 → 무한 루프
  }
for (int j = 0; j < 5; j++)    continue;
 printf("j = %d\\n", j); // 중괄호 없이 작성 → continue만 루프 내부

```

---

💡 보충 설명
- `while (1)`은 의도적으로 무한 루프를 만들 때 자주 사용되지만, 반드시 `break` 등을 통해 탈출 조건이 있어야 합니다.
- `continue`는 해당 반복의 나머지를 건너뛰고 다음 반복으로 이동합니다.
- `for`나 `while`에서 중괄호 `{}`를 생략하면 단 한 줄만 반복에 포함되므로, 들여쓰기만으로 코드 블록을 구분하면 위험합니다.

---

---

## 괄호 닫힘 오류 {#괄호-닫힘-오류}
📌 개념 설명

- 조건문, 반복문, 함수 선언·호출에서 사용하는 괄호 `()`, 중괄호 `{}`, 대괄호 `[]`는 반드시 쌍을 이루어야 합니다.
- 괄호가 열리고 닫히지 않으면 컴파일러는 문장의 경계를 파악하지 못해 문법 오류(syntax error) 를 발생시킵니다.
- 특히 중괄호 `{}`가 누락되면 조건문이나 반복문에 포함되어야 할 코드가 의도와 다르게 실행되는 경우가 많습니다.
- 코드 자동 들여쓰기에 의존하지 말고, 명시적으로 괄호를 사용하는 습관을 들이는 것이 좋습니다.

---

### ✅ 올바른 예시 올바른 예시

```c
int main() {
    int x = 5;
    if (x > 0) {
         printf("양수입니다\\n");
       }
    for (int i = 0; i < 3; i++) {
         printf("i: %d\\n", i);
      }
       return 0;
  }

```

---

### ❌ 잘못된 예시 잘못된 예시

```c
int main() {
    int x = 5;
    if (x > 0 {  // 오류: 괄호 닫힘 누락
         printf("양수입니다\\n");
         for (int i = 0; i < 3; i++ // 오류: 괄호 닫힘 누락
         printf("i: %d\\n", i);
            return 0; // 이 줄도 오류 가능성 있음 (위 문법이 깨졌기 때문)
            }

```

---

💡 보충 설명
- 괄호 문제는 복잡한 조건문이나 다중 반복문에서 특히 많이 발생합니다.
- IDE의 자동 괄호 매칭 기능 또는 문법 강조 도구를 활용하면 괄호 오류를 쉽게 방지할 수 있습니다.

---

---

## 구조체 사용 오류 {#구조체-사용-오류}
📌 개념 설명

- 구조체(`struct`)는 여러 개의 서로 다른 타입의 데이터를 하나로 묶는 사용자 정의 자료형입니다.
- 구조체를 사용하기 위해서는 먼저 구조체의 정의(struct 정의)를 작성해야 합니다.
- 구조체 이름만 선언하고 정의를 생략한 경우, 크기를 알 수 없어 메모리를 할당할 수 없으므로 오류가 발생합니다.
- 또한 구조체 변수를 사용할 때는 `struct` 키워드를 함께 사용하거나, `typedef`로 별칭을 선언해야 합니다.

---

### ✅ 올바른 예시 올바른 예시

```c
// 구조체 정의
struct Student {
    int id;
    char name[20];
   };// 구조체 변수 선언 및 사용
int main() {
    struct Student s1;
    s1.id = 2023;
    strcpy(s1.name, "Alice");
    printf("ID: %d, 이름: %s\\n", s1.id, s1.name);
    return 0;
  }

```

✅ `typedef`를 활용한 간결한 방식:

```c
typedef struct {
    int age;
    float height;
  }Person;
int main() {
    Person p1;
    p1.age = 25;
    p1.height = 175.5;
    return 0;
  }

```

---

### ❌ 잘못된 예시 잘못된 예시

```c
struct Student;
Student s1;  // 오류: 구조체의 정의 없이 사용
s1.id = 1001; // 오류: 구조체 멤버에 접근할 수 없음

```

---

💡 보충 설명
- 구조체 정의 없이 사용하려는 코드는 `"incomplete type"` 오류를 발생시킵니다.
- `#include <string.h>` 없이 `strcpy()`를 사용할 경우에도 오류가 발생할 수 있습니다.
- 구조체 포인터 사용 시 `>` 연산자를 사용하여 멤버에 접근해야 합니다.

---

---

## 메모리 동적 할당 오류 {#메모리-동적-할당-오류}
📌 개념 설명

- C 언어에서 `malloc()`, `calloc()`, `realloc()` 등을 사용하면 런타임 중에 메모리를 동적으로 할당할 수 있습니다.
- 동적 할당을 사용하려면 반드시 `#include <stdlib.h>`를 포함해야 하며, 반환값은 적절한 포인터 타입으로 형 변환(캐스팅)해야 합니다.
- 메모리 할당 실패 시 `malloc()`은 `NULL`을 반환하므로, 반드시 NULL 체크를 해주는 것이 좋습니다.
- 또한, 사용이 끝난 동적 메모리는 반드시 `free()` 함수를 사용하여 명시적으로 해제해야 메모리 누수를 방지할 수 있습니다.

---

### ✅ 올바른 예시 올바른 예시

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    int *arr = (int *)malloc(sizeof(int) * 5); // 동적 할당

    if (arr == NULL) {
        printf("메모리 할당 실패\\n");
        return 1;
    }

    for (int i = 0; i < 5; i++) {
        arr[i] = i * 2;
    }

    for (int i = 0; i < 5; i++) {
        printf("%d ", arr[i]);
    }

    free(arr); // 메모리 해제
    return 0;
}

```

---

### ❌ 잘못된 예시 잘못된 예시

```c
int *arr;
arr = malloc(sizeof(int) * 5);  // 오류: stdlib.h 누락, 캐스팅 없음

arr[0] = 10; // NULL 체크 없음 → 할당 실패 시 세그멘테이션 오류

// free(arr); 없음 → 메모리 누수 발생

```

---

💡 보충 설명
- C에서는 가비지 컬렉션이 없기 때문에 메모리를 직접 관리해야 하며,

`malloc()`으로 할당한 모든 메모리는 `free()`로 해제해야 안전합니다.

- `calloc()`은 초기값을 0으로 설정하며, `realloc()`은 기존 포인터의 크기를 변경할 수 있습니다.

---

---

## 함수 정의 중복 {#함수-정의-중복}
📌 개념 설명

- C 언어에서는 동일한 이름을 가진 함수(특히 매개변수가 동일한 함수)를 여러 번 정의할 수 없습니다.
- 함수 중복 정의는 컴파일 시 `"redefinition of function"` 또는 `"multiple definition"` 오류를 발생시킵니다.
- 이 오류는 주로 다음과 같은 경우에 발생합니다:
- 실수로 같은 함수 내용을 두 번 작성했을 때
- 헤더 파일에 함수 정의를 넣고 여러 파일에서 `#include` 했을 때
- 링크 단계에서 동일한 함수가 두 객체 파일에 중복되어 존재할 때
- 함수 중복 정의를 피하려면 헤더에는 선언만 (`extern`), 구현은 하나의 `.c` 파일에만 작성해야 합니다.

---

### ✅ 올바른 예시 올바른 예시

```c
// header.h
#ifndef HEADER_H
#define HEADER_H

void greet(); // 함수 선언만

#endif

// main.c
#include "header.h"
#include <stdio.h>

void greet() {
    printf("Hello!\\n");
}

int main() {
    greet();
    return 0;
}

```

---

### ❌ 잘못된 예시 잘못된 예시

```c
int main() {
    printf("Hello\\n");
}

int main() { // 오류: main 함수 중복 정의
    printf("World\\n");
}

```

또는

```c
// header.h
void greet() {
    printf("Hi\\n");
}

// main.c와 util.c가 둘 다 header.h를 포함할 경우 중복 정의 오류 발생

```

---

💡 보충 설명
- `inline` 함수나 `static` 함수는 예외적으로 중복 정의를 허용하지만, 그 외에는 항상 함수 정의는 하나만 존재해야 합니다.
- 함수의 이름 충돌을 방지하려면 정확한 모듈 분리와 헤더 보호 매크로 (`#ifndef`, `#define`) 사용이 필수입니다.

---

---

## 잘못된 return 문 {#잘못된-return-문}
📌 개념 설명

- `return` 문은 함수 실행을 종료하고 값을 반환하는 데 사용됩니다.
- `return` 다음에는 반환할 값과 반드시 공백이 있어야 하며, `return0;`처럼 붙여 쓰면 컴파일러가 키워드로 인식하지 못해 오류가 발생합니다.
- 또한, 반환 타입이 `int`인 함수에서는 `return;`만 사용할 수 없으며, 반드시 값을 반환해야 합니다.
- 반대로 `void` 함수에서는 `return 1;`처럼 값을 반환하는 것도 오류입니다.

---

### ✅ 올바른 예시 올바른 예시

```c
int getValue() {
    return 100; // int 함수는 값 반환 필수
}

void sayHello() {
    printf("Hello\\n");
    return;     // void 함수는 return만 가능 (생략도 가능)
}

int main() {
    int result = getValue();
    printf("결과: %d\\n", result);
    return 0;
}

```

---

### ❌ 잘못된 예시 잘못된 예시

```c
int main() {
    return0; // 오류: return과 숫자 사이 공백 없음
}

int foo() {
    return; // 오류: int 함수에서 반환값이 없음
}

void bar() {
    return 1; // 오류: void 함수는 값을 반환하면 안 됨
}

```

---

💡 보충 설명
- `return` 문 뒤에는 항상 세미콜론 `;`가 있어야 하며, 중괄호 내부에 위치해야 합니다.
- 함수 내에서 여러 조건에 따라 종료되는 경우, 모든 경로에 `return` 문이 존재해야 합니다.

---

---

## 선언 위치 오류 {#선언-위치-오류}
📌 개념 설명

- C 언어에서는 변수나 문장은 반드시 유효한 위치(문맥) 에 선언되어야 합니다.
- 예를 들어, 함수 외부에는 실행문을 쓸 수 없고, 블록 내부의 변수는 해당 블록 외부에서 사용할 수 없습니다.
- 또한 선언 전 사용이나, 제어문 외부에서 제어문을 사용하는 경우는 컴파일 오류를 발생시킵니다.
- 변수의 유효 범위(scope) 는 선언 위치에 따라 결정되며, 이를 명확히 이해하고 코딩해야 합니다.

---

### ✅ 올바른 예시 올바른 예시

```c
int global = 100; // 전역 변수

int main() {
    int n;
    scanf("%d", &n);

    for (int i = 0; i < n; i++) {
        printf("%d ", i);
    }

    if (n > 0) {
        int square = n * n;
        printf("제곱: %d\\n", square);
    }

    return 0;
}

```

---

### ❌ 잘못된 예시 잘못된 예시

```c
int N;
for (int i = 0; i < N; i++) {  // 오류: 함수 외부에는 실행문 작성 불가
    printf("%d", i);
}

if (1) {
    int x = 10;
}
printf("%d", x); // 오류: x는 블록 내부에서만 유효

value = 5; // 오류: value 선언 전 사용

```

---

💡 보충 설명
- 전역 변수(Global variable): 함수 외부에서 선언되며 파일 전체에 걸쳐 유효
- 지역 변수(Local variable): 함수 또는 블록 내에서 선언되며, 해당 블록에서만 유효
- 지역 변수는 선언된 위치보다 앞에서는 사용할 수 없습니다.

---

---

---

## 전처리기 오류 {#전처리기-오류}
📌 개념 설명

- 전처리기는 컴파일 전에 수행되는 명령어로, `#include`, `#define`, `#ifdef` 등이 대표적입니다.
- 전처리기 명령은 정확한 문법을 따라야 하며, 잘못 작성하면 컴파일 이전 단계에서 에러가 발생합니다.
- 특히 `#define`에서는 매크로 이름이 숫자로 시작할 수 없고, 공백이나 특수문자가 포함되면 안 됩니다.
- `#include`는 문자열 또는 `<...>` 형식으로 작성되어야 하며, 파일명이 잘못되었거나 존재하지 않으면 오류가 납니다.

---

### ✅ 올바른 예시 올바른 예시

```c
#include <stdio.h>      // 표준 라이브러리 포함
#define MAX 100         // 매크로 정의

int main() {
    int arr[MAX];
    printf("크기: %d\\n", MAX);
    return 0;
}

```

---

### ❌ 잘못된 예시 잘못된 예시

```c
#define 10 MAX      // 오류: 숫자로 시작하는 매크로 이름
#define MAX-VALUE 50 // 오류: 매크로 이름에 특수문자 사용

#include stdio.h    // 오류: 따옴표나 꺽쇠가 없음
#include "missing.h" // 오류: 해당 파일이 존재하지 않음

```

---

💡 보충 설명
- 전처리기는 컴파일러가 코드를 번역하기 전에 실행되므로, 오류가 발생하면 컴파일 자체가 진행되지 않습니다.
- `#define` 매크로는 상수 대체뿐 아니라 간단한 함수처럼 매개변수를 받을 수도 있습니다:

```c
#define SQUARE(x) ((x)*(x))

```

- 매크로를 사용할 때는 괄호를 활용하여 우선순위 오류를 방지하세요.

---

---

## 표준 함수 오용 {#표준-함수-오용}
📌 개념 설명

- C 언어에서 제공하는 표준 함수(`printf`, `scanf`, `strlen`, `malloc` 등)는 정해진 형태로만 사용 가능합니다.
- C에는 `print()` 같은 함수는 존재하지 않으며, 이를 호출하려 하면 “implicit declaration” 또는 “undefined reference” 오류가 발생합니다.
- 또한 표준 함수를 사용하려면 해당 함수를 선언한 헤더 파일을 반드시 포함해야 하며,

이를 생략할 경우 `"implicit declaration of function"` 또는 `"undefined reference"` 오류가 발생합니다.

- 반환값이 있는 함수(`printf`, `strlen`, `scanf`, `malloc` 등)의 결과를 무시하거나 잘못 처리하면 논리적 오류도 발생할 수 있습니다.

---

### ✅ 올바른 예시 올바른 예시

```c
#include <stdio.h>  // printf 선언을 위한 필수 헤더

int main() {
    int len = printf("Hello, world!\\n");  // 반환값: 출력한 문자 수
    printf("총 %d자 출력됨\\n", len);
    return 0;
}

```

---

### ❌ 잘못된 예시 잘못된 예시

```c
print("Hello");  // 오류: C에는 print 함수 없음

int main() {
    strlen("hi");  // 오류: string.h 헤더 누락
}

```

---

💡 **보충 설명**

- `printf()`는 `stdio.h`에 선언되어 있으며, 반환값은 출력된 문자 수입니다.
- `malloc()`은 `stdlib.h`, `strlen()`은 `string.h`, `sqrt()`는 `math.h` 등 함수마다 필요로 하는 헤더가 다릅니다.

---

---

## 함수 인자 순서 오류 {#함수-인자-순서-오류}
📌 개념 설명

- C에서 함수를 호출할 때는 정의된 함수의 인자 순서 및 타입을 정확히 일치시켜야 합니다.
- 인자의 개수, 순서, 타입이 하나라도 일치하지 않으면 `"incompatible pointer type"`, `"too few arguments"` 등의 컴파일 오류가 발생하거나,

컴파일은 되더라도 논리적 오류나 런타임 크래시로 이어질 수 있습니다.

- 특히 포인터 인자, 배열 인자 등은 타입 일치가 매우 중요하며, 순서가 바뀌면 결과가 전혀 달라질 수 있습니다.

---

### ✅ 올바른 예시 올바른 예시

```c
unsigned int dot_product(unsigned int *a, unsigned int *b, int n) {
    unsigned int sum = 0;
    for (int i = 0; i < n; i++) {
        sum += a[i] * b[i];
    }
    return sum;
}

int main() {
    unsigned int A[3] = {1, 2, 3};
    unsigned int B[3] = {4, 5, 6};
    int n = 3;

    unsigned int result = dot_product(A, B, n);  // 순서, 타입 일치
    printf("결과: %u\\n", result);
    return 0;
}

```

---

### ❌ 잘못된 예시 잘못된 예시

```c
unsigned int dot_product(unsigned int *a, unsigned int *b, int n);

int main() {
    unsigned int A[3] = {1, 2, 3};
    unsigned int B[3] = {4, 5, 6};
    int n = 3;

    unsigned int result = dot_product(n, A, B); // 오류: 인자 순서 불일치
    printf("결과: %u\\n", result);
}

```

---

💡 보충 설명
- 함수 정의를 헷갈리지 않도록 함수 원형(prototype)을 명확히 선언하고,

코드 상단 또는 별도 헤더 파일로 관리하는 것이 좋습니다.

- 구조체를 인자로 넘길 때도 멤버 순서나 타입을 정확히 맞춰야 하며,

컴파일은 되더라도 값이 틀어질 수 있으니 주의해야 합니다.

---
